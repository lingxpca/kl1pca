#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "type.h"

int allocateMemory (ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo); 
int kernelMatrix (ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo, char[],int); 

int readdata  (IOINFOptr ioinfo, ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo);
int kernell1pca (ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo);
int pfkpca(ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo);

static void
   free_and_null (char **ptr);

int main (int argc, char *argv[]) 
{
  int status;

  IOINFO      ioinfo;
  ENTITYINFO  entityinfo;
  PROBLEMINFO probleminfo;  
  
  entityinfo.points_XT = NULL;
  entityinfo.K=NULL;
  ioinfo.location = NULL;
  ioinfo.problem  = NULL;
  ioinfo.datafname = NULL;
  ioinfo.datafile  = NULL; 
  
  
	
  if (argc < 3) {
    fprintf (stderr, "Usage \n kernel_l1pca <location> <filename> <q>\n");
    fprintf (stderr, "Example: \n kernel_l1pca ../data toy 2 \n");
    return 1;
  } 
    
  ioinfo.location = (char *) malloc ((PATHLENGTH) * sizeof (char));
  ioinfo.problem  = (char *) malloc ((PATHLENGTH) * sizeof (char));
  strcpy (ioinfo.location, argv[1]);
  strcpy (ioinfo.problem, argv[2]);
  probleminfo.q=atoi(argv[3]);  
  char kernel[10];
  strcpy (kernel,argv[4]);
  int order = atoi(argv[5]);
  
  
  ioinfo.datafname = (char *) malloc ((PATHLENGTH) * sizeof (char));
  strcpy (ioinfo.datafname, ioinfo.location);
  strcat (ioinfo.datafname, ioinfo.problem);
  ioinfo.datafile = fopen (ioinfo.datafname, "r");
  if (ioinfo.datafile == NULL) {
    fprintf (stderr, "Unable to open data file.  Terminating...\n");
    return 1;
  }


  status = readdata(&ioinfo, &entityinfo, &probleminfo);  /* in readdata.c */
  if (status) {
    fprintf (stderr, "Unable to read data.  status %d.  Terminating...\n", status);
    goto TERMINATE;
  }

  status = allocateMemory(&entityinfo, &probleminfo); /* at the end of this file */ 
  if (status) {
    fprintf (stderr, "Unable to allocate memory\n");
    goto TERMINATE;
  }
  
  status = kernelMatrix(&entityinfo, &probleminfo,&kernel[0],order); 
  if (status) {
    fprintf (stderr, "Unable to kernelMatrix\n");
    goto TERMINATE;
  }
   	
  status = pfkpca(&entityinfo, &probleminfo);  
  if (status) {
    fprintf (stderr, "Unable to solve.  Terminating...; or done\n");
    goto TERMINATE;
  } 
   	
  status = kernell1pca(&entityinfo, &probleminfo); /* in solveproblem.c */
  if (status) {
    fprintf (stderr, "Unable to solve.  Terminating...; or done\n");
    goto TERMINATE;
  } 
  

  
TERMINATE:
  
  free_and_null ((char **) &ioinfo.datafname);
  free_and_null ((char **) &entityinfo.K);
  free_and_null ((char **) &probleminfo.PCs);
  return (status);
}
    
static void
free_and_null (char **ptr)
{
   if ( *ptr != NULL ) {
      free (*ptr);
      *ptr = NULL;
   }
} /* END free_and_null */  


int allocateMemory (ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo) 
{
	int numattributes_m = entityinfo->numattributes_m;
	int numentities_n = entityinfo->numentities_n;
	int q = probleminfo->q;
	int i = probleminfo->i; 

	probleminfo->kc=(double *)malloc(numentities_n*sizeof(double));
	probleminfo->c=(double *)malloc(numentities_n*sizeof(double));
	probleminfo->ck_plus1=(double *)malloc(numentities_n*sizeof(double));
	probleminfo->ck=(double *)malloc(numentities_n*sizeof(double));
	probleminfo->data=(double *)malloc(numattributes_m*numattributes_m*sizeof(double));
	
	probleminfo->cstar = (double **)malloc(numentities_n*sizeof(double *));
	for (i=0;i<numentities_n;++i){
	 probleminfo->cstar[i]=(double *)malloc(q*sizeof(double));
	}

	/* for the rotation matrix */
	probleminfo->PCs = (double *) malloc(numattributes_m*q*sizeof(double));

	entityinfo->K=(double **)malloc(numentities_n*sizeof(double *));
	for (i=0;i<numentities_n;++i){
	entityinfo->K[i]=(double *)malloc(numentities_n*sizeof(double));
	}

	entityinfo->KK=(double **)malloc(numentities_n*sizeof(double *));
	for (i=0;i<numentities_n;++i){
	entityinfo->KK[i]=(double *)malloc(numentities_n*sizeof(double));
	}

	return 0;
} /* end allocateMemory */


int kernelMatrix (ENTITYINFOptr entityinfo, PROBLEMINFOptr probleminfo,char* kernel,int order) 
{
	
	int i = probleminfo->i;
	int j = probleminfo->j;
	int k = probleminfo->k;
	int numattributes_m = entityinfo->numattributes_m;
	int numentities_n = entityinfo->numentities_n;
	double *points_XT = entityinfo->points_XT; 


	
	if (strcmp(kernel,"dot")==0) {
	for (i = 0; i<numattributes_m;++i){
		for (j=0;j<numentities_n;++j){
			entityinfo->K[i][j]=0.0;
			for (k=0;k<numentities_n;++k){
				entityinfo->K[i][j] += points_XT[k*numentities_n + i]*points_XT[k*numentities_n+j];
			}
		}
	}
	}	
	
	else if	(strcmp(kernel,"poly")==0){
  	for (i = 0; i<numentities_n;++i){
			for (j=0;j<numentities_n;++j){
				entityinfo->K[i][j]=0.0;
				for (k=0;k<numattributes_m;++k){
					entityinfo->K[i][j] += points_XT[i*numattributes_m + k]*points_XT[j*numattributes_m+k]; 
				}
			entityinfo->K[i][j] = pow(entityinfo->K[i][j]+1,order);
			}
		}
	}
	
	else if (strcmp(kernel,"rbf")==0){
	 	for (i = 0; i<numentities_n;++i){
			for (j=0;j<numentities_n;++j){
				entityinfo->K[i][j]=0.0;
				for (k=0;k<numattributes_m;++k){
					entityinfo->K[i][j] += pow(points_XT[i*numattributes_m + k]-points_XT[j*numattributes_m+k],2); 
				}
			entityinfo->K[i][j] = exp(-entityinfo->K[i][j]/order);
			}
		}	
	}
	 
	for (i = 0; i<numattributes_m;++i)
	{
		for (j=0;j<numentities_n;++j)
		{
			fprintf(stdout,"%4.1f\t", entityinfo->K[i][j]);
		}
		fprintf(stdout,"\n");	
	}
	fprintf(stdout,"******End of Kernel matrix******\n");	
	return 0;
}
























